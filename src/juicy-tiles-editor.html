<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../juicy-highlight/src/juicy-highlight.html">
<link rel="import" href="../../juicy-popover/src/juicy-popover.html">
<link rel="import" href="juicy-color-picker.html">
<link rel="import" href="juicy-tree.html">

<polymer-element name="juicy-tiles-editor" attributes="selectionMode">
  <template>
    <style>
      .editablesContainer {
        display: flex;
      }

      .editableGroup {
        flex: 1 1 auto;
      }

      label {
        display: inline-block;
        white-space: nowrap;
      }

      .val {
        display: inline-block;
        width: 40px;
      }

      .disabled .val {
        visibility: hidden;
      }

      .disabled .editable {
        opacity: 0.5;
        pointer-events: none;
      }

      button {
        min-height: 1.45em;
        min-width: 1.45em;
      }

      button.active {
        box-shadow: inset 0 0 10px #000000;
      }

      button.color {
        border: 1px solid #bbb;
        background: #bbb;
        padding: 4px 2px;
      }

      .expandable {
        background: #fff;
        border: 1px solid rgba(0, 0, 0, .2);
        box-shadow: 0 5px 10px rgba(0, 0, 0, .2);
        padding: 5px;
        width: 144px;
        white-space: normal;
      }

      h4 {
        margin: 0;
        display: inline;
      }

      .sidebar {
        position: fixed;
        top: 150px;
        left: 10px;
        width: 200px;
        height: calc(100% - 160px);
        background: white;
        border: 1px solid black;
        opacity: 0.8;
        overflow: auto;
      }

      .sidebar /deep/ #menu {
        margin-left: 10px;
      }
    </style>
    <div class="{{ {editablesContainer: true, disabled: !editedItem} | tokenList }}">
      <div class="editableGroup">
        <button title="Move selected elements to the same group (CTRL+M)" disabled?="{{selectedItems.length < 1}}" on-click="{{moveSelectionToEditedItemContainer}}">⧉ Move to group</button>
        <button title="Create a new group from selected elements (CTRL+G)" disabled?="{{selectedItems.length < 1}}" on-click="{{newGroupFromSelection}}">⧈ New group</button>
      </div>

      <template if="{{editedItem.items}}">
        <div class="editableGroup">
          <button class="editable" on-click="{{deleteContainer}}" disabled?="{{!editedItem.container}}">⧉ Ungroup</button>
          <button class="editable" on-click="{{changeDirection}}" disabled?="{{!editedItem.container}}">↷Change direction</button>
        </div>

        <div class="editableGroup">
          <h4>Container <code>{{editedItem.name}}</code></h4>
        </div>

        <div class="editableGroup"><label>Background</label>
          <juicy-popover>
            <span class="handle">
              <button class='color' style='background: {{editedItem.background || "transparent"}}'></button>
            </span>
            <div class="expandable">
              <juicy-color-picker value="{{editedItem.background}}" on-juicy-color-picker-value-changed="{{refresh}}"></juicy-color-picker>
            </div>
          </juicy-popover>
        </div>

        <div class="editableGroup">
          <label>Gap <span class="val">({{editedItem.gap}})</span></label>
          <button class="editable" on-click="{{gapIncrease}}">Inc</button>
          <button class="editable" on-click="{{gapDecrease}}">Dec</button>
        </div>
      </template>

      <div class="editableGroup"><label>Width <input class="val" on-blur="{{refresh}}" value="{{editedItem.width}}"></label>
        <button class="editable" on-click="{{widthIncrease}}">Inc</button>
        <button class="editable" on-click="{{widthDecrease}}">Dec</button>
      </div>
      <div class="editableGroup"><label>Height <input class="val" on-blur="{{refresh}}" value="{{editedItem.height}}"></label>
        <button class="editable" on-click="{{heightIncrease}}">Inc</button>
        <button class="editable" on-click="{{heightDecrease}}">Dec</button>
        <label class="editable"><input id="heightAutoCheckbox" type="checkbox" on-click="{{heightAuto}}"> auto</label>
      </div>
      <div class="editableGroup"><label>Priority <span class="val">({{editedItem.priority}})</span></label>
        <button class="editable" on-click="{{priorityIncrease}}">Inc</button>
        <button class="editable" on-click="{{priorityDecrease}}">Dec</button>
      </div>
    </div>

    <div class="sidebar">
      <h1>Elements</h1>
      <juicy-tree id="treeView" tree="{{ tree }}" on-juicy-tree-activate="{{treeActivateBranch}}"
        on-juicy-tree-selection-add="{{selectionAdd}}"
        on-juicy-tree-selection-remove="{{selectionRemove}}"></juicy-tree>
    </div>

    <juicy-highlight id="elementEdited" overlay strokeWidth="3" strokeColor="#33579F" strokeOffset="3"></juicy-highlight>
    <juicy-highlight id="elementRollover" strokeWidth="1" strokeColor="#222222" strokeOffset="4"></juicy-highlight>
    <juicy-highlight id="elementSelected" strokeWidth="1" strokeColor="#33579F" strokeOffset="3"></juicy-highlight>
  </template>
  <script>
    (function () {
      function powerIncrease(obj, property) {
        var power = 1;
        while (power <= obj[property])
          power *= 2;
        obj[property] = power;
      }

      function powerDecrease(obj, property, minimum) {
        var power = 1;
        while (power * 2 < obj[property])
          power *= 2;
        if (power < minimum) {
          power = minimum;
        }
        obj[property] = power;
      }

      /**
       * Returns true if the element would be selected by the specified selector string; otherwise, returns false.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element.matches
       */
      if (!Element.prototype.matches) {
        Element.prototype.matches =
          Element.prototype.webkitMatchesSelector ||
            Element.prototype.mozMatchesSelector ||
            Element.prototype.msMatchesSelector ||
            Element.prototype.oMatchesSelector
      }

      Polymer('juicy-tiles-editor', {
        selectionMode: false,
        editedElement: null,
        highlightedElement: null,
        selectedItems: [],
        selectedElements: [],
        sortableTilesModel: null,
        mouseOverListener: null,
        mouseOutListener: null,
        mouseupListener: null,
        contextMenuListener: null,
        keyUpListener: null,
        tree: {},
        attached: function () {
          this.$.elementEdited.show(this.editedItem ? this.editedItem.element : null);
        },
        detached: function () {
          this.$.elementEdited.hide();
          this.$.elementRollover.hide();
          this.$.elementSelected.hide();
          this.selectionMode = false;
          this.unlisten(); //changing property in "detached" callback does not execute "selectionModeChanged" (Polymer 0.2.3)
        },
        selectionModeChanged: function() {
          if (this.selectionMode) {
            this.listen();
          }
          else {
            this.unlisten();
          }
        },
        getSortableElement: function (elem) {
          while (elem.parentNode) {
            if (elem.parentNode.nodeName == 'JUICY-TILES') {
              return elem;
            }
            elem = elem.parentNode;
          }
        },
        listen: function () {
          this.mouseOverListener = function (ev) {
            this.highlightedElement = null;
            var highlightedElement = this.getSortableElement(ev.target);
            if (highlightedElement) {
              if (this.highlightedElement !== highlightedElement) {
                this.highlightedElement = highlightedElement;
                this.$.elementRollover.show(this.highlightedElement);
              }
            }
          }.bind(this);

          this.mouseOutListener = function (ev) {
            this.$.elementRollover.hide();
          }.bind(this);

          this.mouseupListener = function (ev) {
            if (this.highlightedElement) {
              var model = this.highlightedElement.parentNode;
              this.treeRefresh();
              var highlightedItem = model.items[ model.elements.indexOf(this.highlightedElement) ];
              if (ev.ctrlKey || ev.metaKey || ev.shiftKey) {
                //expand group
                var index = this.selectedItems.indexOf(highlightedItem);
                if(index == -1) {
                  this.selectionAdd(highlightedItem);
                }
                else {
                  this.selectionRemove(highlightedItem);
                }
                this.$.treeView.highlightBranch(highlightedItem, true); //toggles highlight
                this.$.elementSelected.show(this.selectedElements);
              }
              else if (this.editedItem !== highlightedItem) {
                this.$.elementSelected.hide();
                this.editedItem = highlightedItem;
                this.highlightedElement = null;
              }
              ev.preventDefault();
              ev.stopImmediatePropagation();
            }
          }.bind(this);

          this.clickListener = function (ev) {
            var sortableElement = this.getSortableElement(ev.target);
            if(sortableElement) {
              ev.preventDefault();
              ev.stopImmediatePropagation();
            }
          }.bind(this);

          this.contextMenuListener = function (ev) {
            if (ev.ctrlKey) {
              ev.preventDefault(); //on Mac, CTRL+Click opens system context menu, which we would like to avoid
            }
          }.bind(this);

          this.keyUpListener = function (ev) {
            if (ev.ctrlKey || ev.metaKey) { //mind that CTRL+T, CTRL+N, CTRL+W cannot be captured in Chrome
              if (ev.keyCode == 71) { //CTRL+G
                this.newGroupFromSelection();
                ev.preventDefault();
              }
              else if (ev.keyCode == 77) { //CTRL+M
                this.moveSelectionToEditedItemContainer();
                ev.preventDefault();
              }
              else if (ev.keyCode == 85) { //CTRL+U
                //TODO ungroup selection
              }
            }
          }.bind(this);

          window.addEventListener('mouseover', this.mouseOverListener);
          window.addEventListener('mouseout', this.mouseOutListener);
          window.addEventListener('mouseup', this.mouseupListener, true);
          window.addEventListener('mousedown', this.clickListener, true);
          window.addEventListener('click', this.clickListener, true);
          window.addEventListener('contextmenu', this.contextMenuListener);
          window.addEventListener('keyup', this.keyUpListener);
        },
        unlisten: function () {
          window.removeEventListener('mouseover', this.mouseOverListener);
          window.removeEventListener('mouseout', this.mouseOutListener);
          window.removeEventListener('mouseup', this.mouseupListener, true);
          window.removeEventListener('mousedown', this.clickListener, true);
          window.removeEventListener('click', this.clickListener, true);
          window.removeEventListener('contextmenu', this.contextMenuListener);
          window.removeEventListener('keyup', this.keyUpListener);
        },
        toggleSelectionMode: function () {
          this.selectionMode = !this.selectionMode;
        },
        newGroupFromSelection: function () {
          if (!this.editedItem) {
            return;
          }

          var setup = {
            priority: this.editedItem.priority,
            gap: 0,
            index: this.editedItem.index
          }

          var model = this.editedItem.root;
          var newContainer = model.createNewContainer(null, this.editedItem.container, setup, true);
          model.moveToContainer(this.editedItem, newContainer, true);
          for (var i = 0, ilen = this.selectedItems.length; i < ilen; i++) {
            model.moveToContainer(this.selectedItems[i], newContainer, true);
          }

          this.editedItem = newContainer; //change edited item to the new container
          var dimensions = model.getMinimumDimensions(this.getContainerChildElements(newContainer));
          this.editedItem.width = dimensions.width;
          this.editedItem.height = dimensions.height;

          model.packItems(); //rerender
          this.treeRefresh();
        },
        moveSelectionToEditedItemContainer: function () {
          if (!this.editedItem) {
            return;
          }

          var model = this.editedItem.root;
          for (var i = 0, ilen = this.selectedItems.length; i < ilen; i++) {
            model.moveToContainer(this.selectedItems[i], this.editedItem.container, true);
          }

          var dimensions = model.getMinimumDimensions(this.getContainerChildElements(this.editedItem.container));
          this.editedItem.container.width = dimensions.width;
          this.editedItem.container.height = dimensions.height;

          model.packItems(); //rerender
          this.treeRefresh();
        },
        getContainerChildElements: function (container) {
          var model = container.root;
          var elements = [];
          for (var i = 0, ilen = container.items.length; i < ilen; i++) {
            if (container.items[i].index != void 0) {
              elements.push(model.elements[container.items[i].index])
            }
            else if (container.items[i].name != void 0) {
              elements.push(model.elements[container.items[i].name])
            }
          }
          return elements;
        },
        gapIncrease: function () {
          this.editedItem.gap++;
          this.editedItem.root.refresh();
        },
        gapDecrease: function () {
          if (this.editedItem.gap >= 1) {
            this.editedItem.gap--;
          }
          this.editedItem.root.refresh();
        },
        refresh: function () {
          this.editedItem.root.refresh();
        },
        widthIncrease: function () {
          powerIncrease(this.editedItem, "width");
          this.editedItem.root.refresh();
        },
        widthDecrease: function () {
          powerDecrease(this.editedItem, "width");
          this.editedItem.root.refresh();
        },
        heightIncrease: function () {
          if (this.editedItem.height == 'auto') { //turn off auto
            this.editedItem.height = 32;
            this.shadowRoot.querySelector("#heightAutoCheckbox").checked = false;
          }
          powerIncrease(this.editedItem, "height");
          this.editedItem.root.refresh();
        },
        heightDecrease: function () {
          if (this.editedItem.height == 'auto') { //turn off auto
            this.editedItem.height = 32;
            this.shadowRoot.querySelector("#heightAutoCheckbox").checked = false;
          }
          powerDecrease(this.editedItem, "height");
          this.editedItem.root.refresh();
        },
        heightAuto: function () {
          if (this.editedItem.height == 'auto') { //turn off auto
            this.editedItem.height = 32;
          }
          else { //turn on auto
            this.editedItem.height = "auto";
          }
          this.editedItem.root.refresh();
        },
        priorityIncrease: function () {
          this.editedItem.root
            .reprioritizeItem(this.editedItem, true)
            .refresh(); //FIXME: this calls pack items for the second time, consider changing Package.js (tomalec)
        },
        priorityDecrease: function () {
          this.editedItem.root
            .reprioritizeItem(this.editedItem, false)
            .refresh(); //FIXME: this calls pack items for the second time, consider changing Package.js (tomalec)
        },
        deleteContainer: function () {
          var container = this.editedItem.container;
          this.editedItem.root.deleteContainer(this.editedItem);
          this.editedItem = container;
        },
        changeDirection: function(){
          this.editedItem.direction = this.editedItem.direction == "downRight" ? "rightDown" : "downRight";
          this.editedItem.root.refresh();
        },
        getItemElement: function (item) {
          var model = item.root;
          if (item.name) {
            if (item.name === "root") {
              //return;
              return model.shadowRoot.firstElementChild;
            }
            else {
              return model.elements[item.name];
            }
          }
          else {
            return model.elements[item.index];
          }
        },
        editedItemChanged: function() {
          var element = this.getItemElement(this.editedItem);
          this.$.elementEdited.show(element);
          this.$.treeView.highlightBranch(this.editedItem);
          this.selectedItems.length = 0;
          this.selectedElements.length = 0;
        },
        treeActivateBranch: function(ev) {
          this.editedItem = ev.detail.branch;
        },
        treeRefresh: function() {
          var extendWithSubTiles = function (tree) {
            var element = this.getItemElement(tree);
            var nested;
            if (element && element.nodeName == "JUICY-TILES") {
              nested = element;
            }
            else {
              nested = element.querySelector("JUICY-TILES");
            }
            if (nested && !tree.hasOwnProperty("items")) {
              Object.defineProperty(tree, "items", {
                value: [nested.setup]
              });
            }

            if (tree.items) {
              for (var i = 0, ilen = tree.items.length; i < ilen; i++) {
                extendWithSubTiles(tree.items[i])
              }
            }
          }.bind(this);

          //find all trees
          var topmost = this;
          while (topmost.parentNode) {
            topmost = topmost.parentNode;
          }

          var models = topmost.querySelectorAll("JUICY-TILES");
          this.tree = [];
          for (var i = 0, ilen = models.length; i < ilen; i++) {
            if (!models[i].matches("JUICY-TILES JUICY-TILES")) {
              this.tree.push(models[i].setup);
              extendWithSubTiles(models[i].setup);
            }
          }

          Platform.performMicrotaskCheckpoint(); //this is needed because otherwise juicy-tree can't perform first highlightBranch
        },
        selectionAdd: function(item) {
          if(item.detail) {  //is tree event
            item = item.detail.branch;
          }
          this.selectedItems.push(item);
          var elem = item.root.elements[item.name || item.index];
          this.selectedElements.push(elem);
        },
        selectionRemove: function(item) {
          if(item.detail) {  //is tree event
            item = item.detail.branch;
          }
          var index = this.selectedItems.indexOf(item);
          this.selectedItems.splice(index, 1);
          this.selectedElements.splice(index, 1);
        }
      });
    })();
  </script>
</polymer-element>